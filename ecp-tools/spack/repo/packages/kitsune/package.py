# Copyright 2013-2019 Lawrence Livermore National Security, LLC and other
# Spack Project Developers. See the top-level COPYRIGHT file for details.
#
# SPDX-License-Identifier: (Apache-2.0 OR MIT)

from spack import *


class Kitsune(CMakePackage):
    """Kitsune is a fork of LLVM that enables optimization within on-node parallel
    constructs by replacing opaque runtime function calls with true parallel
    entities at the LLVM IR level.
    """

    homepage = 'https://github.com/lanl/kitsune'
    url = 'https://github.com/lanl/kitsune/archive/kitsune-0.8.0.tar.gz'


    family = 'compiler'  # Used by lmod



    # each 'project' here is one that can be enabled in the LLVM_ENABLE_PROJECTS
    # CMake var and has the effect of enabling projects defined in the top-level
    # of the kitsune project. This does not necessarily imply they are part of
    # LLVM_ALL_PROJECTS (referenced with -DLLVM_ENABLE_PROJECTS=all) which has
    # been a moving target during the monorepo transition.
    projects = {
        "clang" : {
            "default" : False,
            "description" : "Build the LLVM C/C++/Objective-C compiler frontend",
        },
        "clang-extra-tools" : {
            "default" : False,
            "description" : "Build the LLVM C/C++/Objective-C compiler frontend",
        },
        "libcxx" : {
            "default" : False,
            "description" : "Build the LLVM C++ standard library",
        },
        "libcxxabi" : {
            "default" : False,
            "description" : "Build the LLVM C++ ABI library",
        },
        "libunwind" : {
            "default" : False,
            "description" : "Build the libcxxabi libunwind"
        },
        "lldb" : {
            "default" : False,
            "description" : "Build the LLVM debugger",
        },
        "compiler-rt" : {
            "default" : False,
            "description" : "Build LLVM compiler runtime, including sanitizers",
        },
        "lld" : {
            "default" : False,
            "description" : "Build the LLVM linker",
        },
        "polly" : {
            "default" : False,
            "description" : "Build the LLVM polyhedral optimization plugin",
        },
        "debuginfo-tests" : {
            "default" : False,
            "description" : "Build tests for checking debug info generated by clang",
        },
    }

    for pname, args in projects.items():
        # NOTE: if the structure of the `projects` dict changes, the dict-splat
        # (**) for kwargs may not be valid in the call to `variant` here
        variant(pname, **args)


    variant('shared_libs', default=False,
            description="Build all components as shared libraries, faster, "
            "less memory to build, less stable")
    variant('link_dylib', default=False,
            description="Build and link the libLLVM shared library rather "
            "than static")
    variant('all_targets', default=False,
            description="Build all supported targets, default targets "
            "<current arch>,NVPTX,AMDGPU,CppBackend")

    # NOTE: The debug version of LLVM is an order of magnitude larger than
    # the release version, and may take up 20-30 GB of space. If you want
    # to save space, build with `build_type=Release`.
    variant('build_type', default='Release',
            description='CMake build type',
            values=('Debug', 'Release', 'RelWithDebInfo', 'MinSizeRel'))
    variant('python', default=False, description="Install python bindings")
    extends('python', when='+python')

    # Build dependency
    depends_on('cmake@3.4.3:', type='build')
    depends_on('python', when='~python', type='build')

    # Universal dependency
    depends_on('python', when='+python')

    # openmp dependencies
    depends_on('perl-data-dumper', type=('build'))

    # lldb dependencies
    depends_on('ncurses', when='+lldb')
    depends_on('swig', when='+lldb')
    depends_on('libedit', when='+lldb')
    depends_on('py-six', when='@5.0.0: +lldb +python')

    # gold support
    depends_on('binutils+gold', when='+gold')

    # polly plugin
    depends_on('gmp', when='@:3.6.999 +polly')
    depends_on('isl', when='@:3.6.999 +polly')

    repo_url = 'https://github.com/lanl/kitsune.git'

    version(0.8.0)
    version('develop', git=repo_url, branch='release/8.x')


    for release in releases:
        if release['version'] == 'develop':
            version(release['version'], svn=release['repo'])

            for rname, repo in release['resources'].items():
                resource(name=rname,
                         svn=repo,
                         destination=resources[rname]['destination'],
                         when='@%s%s' % (release['version'],
                                         resources[rname].get('variant', "")),
                         placement=resources[rname].get('placement', None))
        else:
            version(release['version'], release['md5'], url=llvm_url % release)

            for rname, md5 in release['resources'].items():
                resource(name=rname,
                         url=resources[rname]['url'] % release,
                         md5=md5,
                         destination=resources[rname]['destination'],
                         when='@%s%s' % (release['version'],
                                         resources[rname].get('variant', "")),
                         placement=resources[rname].get('placement', None))

    for release in flang_releases:
        if release['version'] == 'develop':
            version('flang-' + release['version'], git=flang_llvm_url, branch=release['branch'])

            for rname, branch in release['resources'].items():
                flang_resource = flang_resources[rname]
                resource(name=rname,
                         git=flang_resource['git'],
                         branch=branch,
                         destination=flang_resource['destination'],
                         placement=flang_resource['placement'],
                         when='@flang-' + release['version'])

        else:
            version('flang-' + release['version'], git=flang_llvm_url, commit=release['commit'])

            for rname, commit in release['resources'].items():
                flang_resource = flang_resources[rname]
                resource(name=rname,
                         git=flang_resource['git'],
                         commit=commit,
                         destination=flang_resource['destination'],
                         placement=flang_resource['placement'],
                         when='@flang-' + release['version'])



    conflicts('+clang_extra', when='~clang')
    conflicts('+lldb',        when='~clang')

    @run_before('cmake')
    def check_darwin_lldb_codesign_requirement(self):
        if not self.spec.satisfies('+lldb platform=darwin'):
            return
        codesign = which('codesign')
        mkdir('tmp')
        llvm_check_file = join_path('tmp', 'llvm_check')
        copy('/usr/bin/false', llvm_check_file)

        try:
            codesign('-f', '-s', 'lldb_codesign', '--dryrun',
                     llvm_check_file)

        except ProcessError:
            explanation = ('The "lldb_codesign" identity must be available'
                           ' to build LLVM with LLDB. See https://llvm.org/'
                           'svn/llvm-project/lldb/trunk/docs/code-signing'
                           '.txt for details on how to create this identity.')
            raise RuntimeError(explanation)

    
    def setup_environment(self, spack_env, run_env):
        # set the appropriate c++11 flag in the build environment for whatever
        # compiler is being used
        spack_env.append_flags('CXXFLAGS', self.compiler.cxx11_flag)

        # environment vars set in the modulefile
        if '+clang' in self.spec:
            run_env.set('CC', join_path(self.spec.prefix.bin, 'clang'))
            run_env.set('CXX', join_path(self.spec.prefix.bin, 'clang++'))


    # With the new LLVM monorepo, CMakeLists.txt lives in the llvm subdirectory.
    @property
    def root_cmakelists_dir(self):
        """The relative path to the directory containing CMakeLists.txt

        This path is relative to the root of the extracted tarball,
        not to the ``build_directory``. Defaults to the current directory.

        :return: directory containing CMakeLists.txt
        """
        return 'llvm'



    def cmake_args(self):
        spec = self.spec
        cmake_args = [
            '-DLLVM_REQUIRES_RTTI:BOOL=ON',
            '-DLLVM_ENABLE_RTTI:BOOL=ON',
            '-DLLVM_ENABLE_EH:BOOL=ON',
            '-DCLANG_DEFAULT_OPENMP_RUNTIME:STRING=libomp',
            '-DPYTHON_EXECUTABLE:PATH={0}'.format(spec['python'].command.path),
        ]

        # TODO: Instead of unconditionally disabling CUDA, add a "cuda" variant
        #       (see TODO above), and set the paths if enabled.
        cmake_args.extend([
            '-DCUDA_TOOLKIT_ROOT_DIR:PATH=IGNORE',
            '-DCUDA_SDK_ROOT_DIR:PATH=IGNORE',
            '-DCUDA_NVCC_EXECUTABLE:FILEPATH=IGNORE',
            '-DLIBOMPTARGET_DEP_CUDA_DRIVER_LIBRARIES:STRING=IGNORE'])

        if '+gold' in spec:
            cmake_args.append('-DLLVM_BINUTILS_INCDIR=' +
                              spec['binutils'].prefix.include)
        if '+polly' in spec:
            cmake_args.append('-DLINK_POLLY_INTO_TOOLS:Bool=ON')
        else:
            cmake_args.extend(['-DLLVM_EXTERNAL_POLLY_BUILD:Bool=OFF',
                               '-DLLVM_TOOL_POLLY_BUILD:Bool=OFF',
                               '-DLLVM_POLLY_BUILD:Bool=OFF',
                               '-DLLVM_POLLY_LINK_INTO_TOOLS:Bool=OFF'])

        if '+python' in spec and '+lldb' in spec and spec.satisfies('@5.0.0:'):
            cmake_args.append('-DLLDB_USE_SYSTEM_SIX:Bool=TRUE')
        if '+clang' not in spec:
            cmake_args.append('-DLLVM_EXTERNAL_CLANG_BUILD:Bool=OFF')
        if '+lldb' not in spec:
            cmake_args.extend(['-DLLVM_EXTERNAL_LLDB_BUILD:Bool=OFF',
                               '-DLLVM_TOOL_LLDB_BUILD:Bool=OFF'])
        if '+lld' not in spec:
            cmake_args.append('-DLLVM_TOOL_LLD_BUILD:Bool=OFF')
        if '+internal_unwind' not in spec:
            cmake_args.append('-DLLVM_EXTERNAL_LIBUNWIND_BUILD:Bool=OFF')
        if '+libcxx' in spec:
            cmake_args.append('-DCLANG_DEFAULT_CXX_STDLIB=libc++')
        else:
            cmake_args.append('-DLLVM_EXTERNAL_LIBCXX_BUILD:Bool=OFF')
            cmake_args.append('-DLLVM_EXTERNAL_LIBCXXABI_BUILD:Bool=OFF')
        if '+compiler-rt' not in spec:
            cmake_args.append('-DLLVM_EXTERNAL_COMPILER_RT_BUILD:Bool=OFF')

        if '+shared_libs' in spec:
            cmake_args.append('-DBUILD_SHARED_LIBS:Bool=ON')

        if '+link_dylib' in spec:
            cmake_args.append('-DLLVM_LINK_LLVM_DYLIB:Bool=ON')

        if '+all_targets' not in spec:  # all is default on cmake

            targets = ['NVPTX', 'AMDGPU']

            if 'x86' in spec.architecture.target.lower():
                targets.append('X86')
            elif 'arm' in spec.architecture.target.lower():
                targets.append('ARM')
            elif 'aarch64' in spec.architecture.target.lower():
                targets.append('AArch64')
            elif 'sparc' in spec.architecture.target.lower():
                targets.append('Sparc')
            elif ('ppc' in spec.architecture.target.lower() or
                  'power' in spec.architecture.target.lower()):
                targets.append('PowerPC')

            cmake_args.append(
                '-DLLVM_TARGETS_TO_BUILD:STRING=' + ';'.join(targets))

        if spec.satisfies('@4.0.0:') and spec.satisfies('platform=linux'):
            cmake_args.append('-DCMAKE_BUILD_WITH_INSTALL_RPATH=1')
        return cmake_args

    @run_before('build')
    def pre_install(self):
        with working_dir(self.build_directory):
            # When building shared libraries these need to be installed first
            make('install-LLVMTableGen')
            if self.spec.version >= Version('4.0.0'):
                # LLVMDemangle target was added in 4.0.0
                make('install-LLVMDemangle')
            make('install-LLVMSupport')

    @run_after('install')
    def post_install(self):
        if '+clang' in self.spec and '+python' in self.spec:
            install_tree(
                'tools/clang/bindings/python/clang',
                join_path(site_packages_dir, 'clang'))

        with working_dir(self.build_directory):
            install_tree('bin', join_path(self.prefix, 'libexec', 'llvm'))
